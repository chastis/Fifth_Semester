#include <iostream>
#include <vector>
#include <queue>

using namespace std;

/* Алгоритм поиска в ширину в невзвешенном графе находит длины кратчайших путей до всех достижимых вершин.

Доказательство:
Допустим, что это не так. Выберем из вершин, для которых кратчайшие пути от s найдены некорректно, ту, настоящее расстояние до которой минимально. Пусть это вершина u, и она имеет своим предком в дереве обхода в ширину v, а предок в кратчайшем пути до u — вершина w.

Так как w — предок u в кратчайшем пути, то ρ(s,u)=ρ(s,w)+1>ρ(s,w), и расстояние до w найдено верно, ρ(s,w)=d[w]. Значит, ρ(s,u)=d[w]+1.

Так как v — предок u в дереве обхода в ширину, то d[u]=d[v]+1.

Расстояние до u найдено некорректно, поэтому ρ(s,u)<d[u]. Подставляя сюда два последних равенства, получаем d[w]+1<d[v]+1, то есть, d[w]<d[v]. Из ранее доказанной леммы следует, что в этом случае вершина w попала в очередь и была обработана раньше, чем v. Но она соединена с u, значит, v не может быть предком u в дереве обхода в ширину, мы пришли к противоречию, следовательно, найденные расстояния до всех вершин являются кратчайшими.
*/


int main(int argc, const char * argv[]) {
	\
		int n, m;
	cout << "Введите количство вершин" << endl;
	cin >> n;
	cout << "Введите количство ребер" << endl;
	cin >> m;
	//двумерный масив ребро и вершины этого ребра
	vector<vector<int> > g(n);
	int to, from;
	for (int i = 0; i < m; ++i) {
		cout << "Введите ребро для списка инцидентности" << endl;
		cin >> from >> to;
		/*
		1 2
		1 3
		2 4
		2 3
		*/
		from--;
		to--;
		g[from].push_back(to);
		g[to].push_back(from);

	}
	//очередь
	queue<int> q;
	//там где мы были
	vector<int> used(n, 0);
	//дистанция для элементов от первого
	vector<int> dist(n, 0);
	dist[0] = 0;
	int s;
	q.push(0);

	while (!q.empty()) {
		//возвращает первый элемент очереди
		s = q.front();
		//удаляет первый
		q.pop();
		for (int i = 0; i < g[s].size(); ++i) {
			if (!used[g[s][i]]) {
				q.push(g[s][i]);
				used[g[s][i]] = true;
				dist[g[s][i]] = dist[s] + 1;
			}
		}
	}
	dist[0] = 0;

	for (int i = 1; i < n; ++i) {
		cout << "Из начальной до " << i << " вершины путь из " << dist[i] << " ребер" << endl;
	}
}

