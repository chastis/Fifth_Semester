# ControlWork2
modular work #2

Описати структуру даних для подання множин – куль у тривимірному
декартовому просторі (координати центру та радіус кулі є дійсними
числами). Реалізувати функцію для виводу множини. Реалізувати функції
для перевірки, а) чи дві множини перетинаються; б) чи одна множина
повністю вкладена в іншу (є підмножиною). Реалізувати функцію для
генерації випадкової множини відповідно до правил, описаних у
підваріантах. Згенерувати 110 випадкових множин, попарно перевірити на
перетин та вкладеність, вивести відсоток множин, що знаходяться у цих
відношеннях (отриманий результат також зберегти, наприклад, у
текстовому файлі, і здати разом з контрольною). 
Підваріанти:2) координати центру від -10 до 10, радіус від 0
до 5, значення у вигляді n/2 10 (n – ціле), об’єм не менше 15;

Описати структуру даних – дерево з довільною кількістю «дітей» для
зберігання множин із завдання 1. Дерево будується відповідно до такого
правила: множина P може бути «батьківською» для множини C, якщо C
повністю вкладається в P. Коренем вважається «універсальна множина», в
яку повністю вкладаються всі можливі множини. Кожному вузлу дерева
також присвоєно унікальний номер. Реалізувати функцію для виводу
дерева. Реалізувати функцію для додавання нової множини в дерево
(намагаючись вставити нову множину якомога глибше в дереві).
Побудувати дерево відповідно до підваріантів. В цьому завданні можна
задавати множини для дерева в коді, чи вводити з файлу (який треба здати
разом з контрольною), чи задавати випадковим чином, чи певну
комбінацію з цих варіантів. Множини не обов’язково відповідають
обмеженням із завдання 1. 
Підваріанти: 2) не менше 23 вузлів дерева, глибина не менше 5, не менше 2 листових
вузлів максимальної глибини;

Описати структуру даних – неорієнтований граф для зберігання множин із
завдання 1. Між двома вершинами графа є ребро, якщо відповідні
множини перетинаються (якщо множина C повністю вкладається в
множину P, то, очевидно, вони перетинаються). Реалізувати функції для
виводу графа та для додавання вершин та ребер в граф. На основі дерева із
завдання 2 побудувати послідовність графів, які містять вершини з під-
дерев глибини k=1, 2, …, M (тобто всі вузли дерева з глибиною не більше
k; M – максимальна глибина дерева). Буде корисно не робити повну
попарну перевірку вершин для знаходження ребер, а використати
структуру дерева, побудованого у завданні 2 (за ефективну реалізацію
будуть виставлені додаткові бали).
Підваріанти:2) подання графа у вигляді матриці суміжності;

Описати структуру даних – бінарне дерево для зберігання множин із
завдання 1. Вибирається максимальний граф, побудований в завданні 3, і
для кожної його вершини обчислюється функція відповідно до
підваріанту. Вершини додаються в бінарне дерево за зростанням
відповідної функції (тобто ліва дитина має менше значення функції, ніж
батьківський вузол дерева, а права дитина – більше). Реалізувати функції
для виводу дерева та додавання вузла.
Підваріанти: 2) кількість вершин на
відстані 3 від заданої вершини;
